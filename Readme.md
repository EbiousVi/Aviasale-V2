##  Ebiuos Aviasale App ##
***
### Stack ###
**Back**:
Spring: Boot, MVC, Data, Security; JWT, JUnit5, Mockito, AssertJ, TestContainers
<br/>
**Front**:
Vue JS 2, vue-router, vuex, vuetify-js
<br/>
**DB**:
PostgreSQL, Flyway
<br/>
**Docker**:<br/> [Docker-compose](docker-compose.yaml) запуск проекта из образов с Docker-Hub<br/>
[Docker-compose](docker/docker-compose.yaml) сборка из проекта, необходимо скачать 
[скрипт](https://edu.postgrespro.ru/demo-small.zip). <br/>
Размер: Back ~ 150mb, Front ~ 270mb, DB ~ 420mb, Total ~ 840mb<br/>
Контейнер бэкенда будет перезагружаться, пока инициализация скрипта демо-базы не завершится и
postgres не откроет порт для подключения.<br/>
**You-tube**: https://youtu.be/Pcm7sACe6fY

### Описание ###
Приложение для поиска и бронирования авиабилетов, на основе демо-базы предоставляемой
[Postgres Pro](https://postgrespro.ru/education/demodb). В рамках учебного проекта. 
Построено вокруг схемы демонстрационной базы Postgres. 
[Описание схемы](https://postgrespro.ru/docs/postgrespro/10/apjs03.html).
С некоторыми допущениями.
[Список сокращений в коде](abbriviation.md)

### Основные моменты ### 

* Полет из точки А в точку Б, напрямую не всегда возможен, 
поэтому полеты делятся на два типа: прямые (direct) и составные (connection) <br/>
* Система использует два вида поездок (trip): 
в одну сторону (oneway trip) и туда и обратно (round trip)<br/>
* Все доступные полеты для поиска лежат в интервале от 2017-08-15 до 2017-09-14<br/>
* Полеты в которых пассажиры приобрели посадочные талоны находятся в интервале 2017-08-15 - 2017-08-16 

### Поисковая система ###
Поисковая система состоит из [движка](src/main/java/com/ebious/aviasale/service/searchFlight/engine/EngineImpl.java), 
который использует паттерн [Команда](src/main/java/com/ebious/aviasale/service/searchFlight/searchCommand),
для выбора типа полета в зависимости от условий. Внутри себя, 
каждая Команда используют паттерн [Стратегия](src/main/java/com/ebious/aviasale/service/searchFlight/strategies),
для различных вариаций поиска конкретного типа полета. 
Что позволяет легко, добавлять новые вариации запросов в систему. 
Для упрощения вывода на фронтэнд, все Стратегии возвращают результат в виде списка полетов `List<Flights>`,
так как полет, напрямую в одну сторону не всегда возможен. 
`List<Flights>` некая атомарная сущность которая может состоять как из одного полета, так и нескольких.<br/>

Время в демо-базе хранится со смещением GMT+3, вне зависимости от времени хоста. Добавим немного реализма.
[Сервис](src/main/java/com/ebious/aviasale/service/SearchQueryService.java)
по обработке запроса игнорирует год и месяц, но проверяет день месяца и время.
1. Если смещения во времени между клиентом и сервером равны 
    + проверяем на равенство день вылета указанный в запросе с текущим днем сервера, если они равны
        - то к дате вылета добавляется текущие время 
         плюс резервное время для возможности совершить бронирование. 
        - Если даты отличаются, используем дату вылета и время начала и конца дня.
2. Если смешения не равны, приложение приводит время клиента к времени сервера.
    + Если после перевода день месяца клиента равен дню месяца вылета, 
      то к дате вылета добавляется переведенное время клиента плюс резерв.
    + Если переведенный день месяца больше дня вылета на один день, 
      то к дате вылета добавляется один день и переведенное время клиента плюс резерв.
    + Если переведенный день месяца меньше дня вылета на один день, 
      то от даты вылета вычитается один день и добавляется переведенное время клиента плюс резерв.
    + В остальных случаях используется время начала и конца для дня указанного в запросе.

### Бронирование ###

[Бронирование](src/main/java/com/ebious/aviasale/service/TryBookingService.java) базируется на таблице ticket_flights. 
Если таблица не содержит записей с идентификатором полета, который имеет статус Scheduled, On-Time, Delayed
следовательно, не было ни одного бронирования на данный рейс. Необходима система учёта, 
которая должна ограничить количество записей, в соответствии с моделью самолета и классом обслуживания. 
Для этого используется табличный триггер before insert. [Код триггера](src/test/resources/migration/V4__add_booking_system.sql). 
Триггер вычисляет количество мест исходя из модели самолета и класса обслуживания, 
и вычитает количество записей в таблице ticket_flights
по идентификатору полета и классу обслуживанию. 
Этого не достаточно чтобы, не допустить лишние вставки в параллельных транзакциях. 
Необходим механизм блокировки, для этого триггер использует блокировку, 
доступную только в Postgres, advisory lock(flight_id) по идентификатору полета. 
Которая блокирует записи для конкретного полета, тем самым не мешая,
бронированию других полетов. В случае успешного бронирования, 
пользователь получает список всех бронирований, где может зарегистрироваться на рейс.

### Учётные записи ### 

Для бронирования пользователь должен быть зарегистрирован в системе. 
Все запросы требующие аутентификации и авторизации используют jwt token.

### Тесты ### 
Проект учебный и писать полноценные тесты, нет мотивации. 
И как оказалось проще писать их сразу.
Так что тесты написанные не в полном объеме, не по канонам.
Но общее представление понимание однозначно получено.

 